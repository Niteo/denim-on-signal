import SignalLib = require('@signalapp/libsignal-client');
import { ProtoFactory } from './ProtoFactory'
import Constants = require('./Constants');
import { denim_proto } from '../proto-generated/compiled';
import yargs from "yargs";
import { uint8Array } from 'fast-check';
import { add } from 'mathjs';

const timer = require('relative-microtime')();

const fs = require('fs');
const logLevel = yargs.argv.debugutil ? 'debug' : 'info';
const logger = require('./Logger').getLogger("Utils",logLevel);
const info = x => logger.info(x)
const debug = x => logger.debug(x)
const error = x => logger.error(x);

const minPadding = yargs.argv.padding != undefined && yargs.argv.padding ? yargs.argv.padding : Constants.MIN_PADDING;

if(minPadding<Constants.MIN_PADDING) {
    error(`Illegal provided for --padding. Should be >= ${Constants.MIN_PADDING}, got ${minPadding}`);
    process.exit(3);
}


const RUN_ASSERTS = yargs.argv.runasserts ? true : false;
function assert (f) { if (RUN_ASSERTS) {f (); }}

const randomQuotes = require('random-quotes');

export function stringToSignalProtocolAddress(address:string){
    const dict = JSON.parse(address);
    return SignalLib.ProtocolAddress.new(dict["name"], dict["deviceId"]);
}

export function concatUint8Array(first:Uint8Array, last:Uint8Array) {
    var result = new Uint8Array(first.byteLength+last.byteLength);
    result.set(first, 0);
    result.set(last, first.byteLength);
    return result;
}

export function signalAddressToString(address:SignalLib.ProtocolAddress){
    const dict = {"name": address.name(), 
    "deviceId": address.deviceId()};
    return JSON.stringify(dict);
}

export function denimAddressToString(address:denim_proto.IProtocolAddress){
    return JSON.stringify(address);
}

export function geometricMean(values:Array<number>) {
    const n = values.length;
    const root = 1/n;
    const product = values.reduce(function (aggregator, next) { 
        return aggregator*next});
    return Math.pow(product, root); // nth root of product
}

export function choose(choices) {
    const index = Math.floor(Math.random() * choices.length);
    return choices[index];
}

export function doWithProbability(probability:number) {
    const rnd = 1 - Math.random();
    return rnd <= probability; // Sanity: 1 should return true, 0 false
}

export function getGenerator(seed:Uint8Array) {
    const deterministicRng = require('random-seed').create(seed); // Deterministic!
    deterministicRng.seed(seed); // Deterministic!
    return deterministicRng;
}

export function generateIdWithoutCollision(rng:any, existingIds:Array<number>) {
    let hasCollision = true;
    let id:number;
    while(hasCollision) {
        id = rng.intBetween(Constants.KEY_START_ID, Constants.KEY_STOP_ID); //[start, stop]
        if(existingIds.findIndex(x=> x==id)==-1){
            hasCollision = false;
        }
    }

    return id;
}

export function generateKey(rng:any) {
    const bytes = new Array<number>();
    for(let i=0;i<Constants.SIGNAL_KEY_LENGTH;i++) {
        bytes.push(rng(256)); // Random byte
    }

    // https://www.ietf.org/rfc/rfc7748.txt
    // FROM RFC (Elliptic Curves for Security) page 7:

    // Scalars are assumed to be randomly generated bytes.  For X25519, in
    // order to decode 32 random bytes as an integer scalar, set the three
    // least significant bits of the first byte and the most significant bit
    // of the last to zero, set the second most significant bit of the last
    // byte to 1 and, finally, decode as little-endian.  This means that the
    // resulting integer is of the form 2^254 plus eight times a value
    // between 0 and 2^251 - 1 (inclusive).  Likewise, for X448, set the two
    // least significant bits of the first byte to 0, and the most
    // significant bit of the last byte to 1.  This means that the resulting
    // integer is of the form 2^447 plus four times a value between 0 and
    // 2^445 - 1 (inclusive).

    // <CODE BEGINS>
    // def decodeScalar25519(k):
    //     k_list = [ord(b) for b in k]
    //     k_list[0] &= 248
    //     k_list[31] &= 127
    //     k_list[31] |= 64
    //     return decodeLittleEndian(k_list, 255)
    bytes[0] &= 248; //1111 1000
    bytes[31] &= 127; //0111 1111
    bytes[31] |= 64; //0100 0000


    const byteBuffer = Buffer.from(bytes);
    const generatedKey = SignalLib.PrivateKey.deserialize(byteBuffer);
    return generatedKey;
}

export function calculatePaddingLength(q:number, messageLength:number) {
    return Math.ceil(messageLength*q);
}

export function getDeniableChunks(q:number, regularPayloadLength:number, currentChunk:Uint8Array, deniableBuffer:Array<denim_proto.DeniablePayload>, receiver:string="unknown") {
    debug(`-------getDeniableChunks--------`)
    const chunks = new Array<denim_proto.DenimChunk>();
    let outgoingCurrentChunk = Constants.EMPTY_UINT8ARRAY;

    // Special "base case"; no deniable traffic
    if(q==0){
        return {"chunks":chunks, "state":outgoingCurrentChunk, "ballast":0};
    }

    let finalChunkLength = calculatePaddingLength(q, regularPayloadLength);
    if(finalChunkLength<minPadding){
        debug(`SPECIALCASE: padding is smaller than allowed! Updating finalChunkLength from ${finalChunkLength} to ${minPadding}`);
        finalChunkLength = minPadding; // Smallest allowed size, dummy padding
    } else {
        debug(`finalChunkLength is ${finalChunkLength}`);
    }

    let toAdd = currentChunk; // Driver
    debug(`toAdd starts as value: ${toAdd}`);


    function getNextChunk(availableBytes:number) {
        // Chunking already begun? Resume, or move to next payload

        if (toAdd?.byteLength == 0) {
            toAdd = Constants.EMPTY_UINT8ARRAY;
        }

        if(toAdd.length<=0 && outgoingCurrentChunk.length<=0) { //Defensive check
            // Move on to next payload if one is available
            if(deniableBuffer && deniableBuffer.length >0){
                const next = deniableBuffer.shift();
                toAdd = denim_proto.DeniablePayload.encode(next).finish();
                debug(`Payload to chunk: ${Buffer.from(toAdd).toString('hex')}`);
                debug(`Length of deniable payload being chunked is ${toAdd.byteLength}`);
            } else {
                return null;  // we return null because there is nothing else to read from the buffer 
            }  
        }

        
        let ret = {"content":Constants.EMPTY_UINT8ARRAY, "isFinal":false}; // State to return

        if(availableBytes>=toAdd.byteLength){ // Easy case, just add everything
            outgoingCurrentChunk = Constants.EMPTY_UINT8ARRAY;
            ret.content=toAdd;
            ret.isFinal=true;

        } else { // We can't add the full thing, find out where to cut and save intermediary state
            outgoingCurrentChunk = toAdd.slice(availableBytes, toAdd.length); // Save in state
            ret.content = toAdd.slice(0, availableBytes);
            ret.isFinal = false;
        }

        toAdd = Constants.EMPTY_UINT8ARRAY;
        return ret;

    }

    let availableBytes = finalChunkLength-Constants.UNUSED_BALLAST_FLAG_OVERHEAD;

    
    while (availableBytes > Constants.DENIMARRAY_WITH_EMPTY_DENIMCHUNK_SIZE) { 
        debug(`${availableBytes} bytes available, continuing to add chunks until size reaches ${finalChunkLength}`);
  
        const available_raw_for_chunk = lookupSizeRawOfEncoded(availableBytes - Constants.PROTO_TAG_SIZE)
        const availbale_encoded_for_buffer = available_raw_for_chunk - Constants.DENIMCHUNK_NONCHUNK_MIN_LENGTH
        let available_raw_for_buffer = lookupSizeRawOfEncoded(availbale_encoded_for_buffer);

        // Get chunk material if there's a deniable payload buffered
        debug(`requesting chunk material of size ${available_raw_for_buffer}`)
        const chunkMaterial = getNextChunk(available_raw_for_buffer);

        // Case: With deniable payload
        if(chunkMaterial) {
            // Important that we do not decrement availableBytes before we 
            // have obtained chunk material; otherwise, we're off by one
            // in generaation of the padding chunk
            availableBytes -= Constants.PROTO_TAG_SIZE;
            const actual_bytes_raw = chunkMaterial.content.byteLength;

            debug (`chunk material has size ${actual_bytes_raw}`);
            const actual_bytes_encoded = sizeEncodedOfRaw(actual_bytes_raw);
            const actual_chunk_raw = actual_bytes_encoded + Constants.DENIMCHUNK_NONCHUNK_MIN_LENGTH;
            const actual_chunk_encoded = sizeEncodedOfRaw(actual_chunk_raw);

            debug(`availableBytes ${availableBytes}`);
            availableBytes -= actual_chunk_encoded;            
            debug(`availableBytes ${availableBytes}`);
            
            const chunk = ProtoFactory.denimChunk(chunkMaterial.content, chunkMaterial.isFinal);
            chunks.push(chunk);
            
        } else {
            debug (`chunk material not available; proceeding to finalize the message`)
            break;
        }
    }
    if(availableBytes >= Constants.DENIMARRAY_WITH_EMPTY_DENIMCHUNK_SIZE) { // Case: dummy chunk
        debug (`leftover bytes for dummy padding are ${availableBytes}`)
        
        const available_raw_for_chunk = lookupSizeRawOfEncoded(availableBytes - Constants.PROTO_TAG_SIZE);
        const availbale_encoded_for_buffer = available_raw_for_chunk - Constants.DENIMCHUNK_NONCHUNK_MIN_LENGTH
        const available_raw_for_buffer = lookupSizeRawOfEncoded(availbale_encoded_for_buffer);                
        const chunk = ProtoFactory.dummyChunk(available_raw_for_buffer);
        chunks.push(chunk);  

        let _a1 = available_raw_for_buffer 
                + varintSizeOfNumber (available_raw_for_buffer) 
                + Constants.DENIMCHUNK_NONCHUNK_MIN_LENGTH 
        let _a2 = _a1 + varintSizeOfNumber (_a1) + Constants.PROTO_TAG_SIZE
        availableBytes -= _a2
    }
 
    debug (`******** finished the message ******`)
    return {"chunks":chunks, "state":outgoingCurrentChunk, "ballast":availableBytes};
}

function lookupSizeRawOfEncoded (l:number) {
    return l - _lookupVarintOverhead (l)  
}

function sizeEncodedOfRaw (l:number) {
    return l + varintSizeOfNumber (l)
}

export function makeRepeatableDummyChunk (rlen:number) { 
    // we have to reserve 1 byte for the tag
    // so we have rlen - 1 for storing the size and the payload
    let len_of_padding = rlen - Constants.PROTO_TAG_SIZE
    const _b = findBallast(len_of_padding)
    let len = lookupSizeRawOfEncoded (len_of_padding) 
    if (_b > 0) {
        // special case 
        debug (`rep dumm ballast ${_b}`)
        let _b2 = len_of_padding + _b
        let x = sizeEncodedOfRaw (_b)
        return makeDummyChunk(_b2)        

    } else {
        return makeDummyChunk(len)
    }
}

function findBallast (x:number) {
    const B = Constants._BYTE_SIZE_GAPS
    for (let i = 0; i < B.length; i++) {
        if ( x < B[i] ) {
            return 0;
        }
        if (x == B[i]) {            
            return (i + 1);
        }
    }
    error (`findBalast: length too large ${x}`)   
    throw new Error("findBallast")
}

export function makeDummyChunk (chunkLen:number) {
    
    const encodedByteLen = chunkLen - Constants.DENIMCHUNK_NONCHUNK_MIN_LENGTH    
    debug (`-- encodedByteLen ${encodedByteLen}`)
    const rawByteLen = lookupSizeRawOfEncoded (encodedByteLen)
    debug (`-- rawByteLen ${rawByteLen}`)
    const ballast = findBallast (encodedByteLen);
    debug (`-- ballast ${ballast}`)
    // const dummyPadding = new Uint8Array(rawByteLen); // Zero-padded 
    return {"chunk":ProtoFactory.dummyChunk(rawByteLen), "ballast":ballast};
}



export function _lookupVarintOverhead (x:number) {
    const B = Constants._BYTE_SIZE_GAPS
    for (let i = 0; i < B.length; i++) {
        if ( x < B[i] ) {
            return (i+1);
        }     
    }
    return B.length + 1;
}


export function varintSizeOfNumber(length:number) {
    let size = 1;
    if(length>127) {
        size = Math.ceil(Math.log2(length+1)/7);
    }
    return size; 
}


export function getQuote() {
    return randomQuotes.default().body;
}

export function getSignalAddressesExcludingSelf(allNames:Array<number>, nameSelf:number) {
    const addresses = new Array<SignalLib.ProtocolAddress>();
    for(const contact of allNames) {
        if(contact != nameSelf) {
            addresses.push(SignalLib.ProtocolAddress.new(contact.toString(), Constants.DEFAULT_DEVICE_ID));
        }
    }
    return addresses;
}

export function createFolder(outputDir:string) {
    // Start with clean directory
    if(fs.existsSync(outputDir)) {
        fs.rmSync(outputDir, { recursive: true }, (err) => { 
            if (err) {
                throw err;
            }
        });
    }
    // Create new directory
    fs.mkdirSync(outputDir, { recursive: true }, (err) => {
        if (err) {
            throw err;
        }
    });
}

export function getDelimitedTimestamp() {
    return `${Constants.MESSAGE_TIMESTAMP_START_DELIMITER}${timer()}${Constants.MESSAGE_TIMESTAMP_END_DELIMITER}`;
}

export function getRelativeTimeMicroseconds() {
    return timer();
}

export function fatalExit(s) {
    error(`Fatal exit: ${s}`);
    error(`Trace: ${new Error("Fatal error").stack}`)
    process.exit(-1);    
}

export function hasNotTimedOut(startTime:number, duration:number) {
    let notTimedOut = true;

    if (Date.now() - startTime > duration) {
        notTimedOut = false;
    } 

    return notTimedOut;
}