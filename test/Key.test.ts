import SignalLib = require('@signalapp/libsignal-client');
import { newDenimClient } from '../src/core/DenimClient';
import { DenimServer } from '../src/core/DenimServer';
import Util = require('../src/helper/Util');
import Constants = require('../src/helper/Constants');
import { denim_proto } from "../src/proto-generated/compiled";

const crypto = require('crypto');

const test = require('tape');

// SignalLib.initLogger(
//     SignalLib.LogLevel.Trace,
//     (level, target, fileOrNull, lineOrNull, message) => {
//       const targetPrefix = target ? '[' + target + '] ' : '';
//       const file = fileOrNull ?? '<unknown>';
//       const line = lineOrNull ?? 0;
//       // eslint-disable-next-line no-console
//       console.log(targetPrefix + file + ':' + line + ': ' + message);
//     }
// );  

test('Random byte array to key', async (tape)=> {
    // Idea
    // Seed RNG with crypto strength randomness
    // RNG: generate random a
    // SignalLib.PrivateKey.deserialize() // parse a to signal key
    // Create public version: g^a
    const seedLength = 32; // Same as key length should be enough
    const seed = crypto.randomBytes(seedLength);
    const range = 256; // [0,255] 1 byte
    const length = 32; //Signal's key length
    const deterministicRng = require('random-seed').create(seed); // Deterministic!

    deterministicRng.seed(seed); // Deterministic!
    const bytes = new Array<number>();
    for(let i=0;i<length;i++) {
        bytes.push(deterministicRng(range)); // Random byte
    }

    // https://www.ietf.org/rfc/rfc7748.txt
    // FROM RFC (Elliptic Curves for Security) page 7:

    // Scalars are assumed to be randomly generated bytes.  For X25519, in
    // order to decode 32 random bytes as an integer scalar, set the three
    // least significant bits of the first byte and the most significant bit
    // of the last to zero, set the second most significant bit of the last
    // byte to 1 and, finally, decode as little-endian.  This means that the
    // resulting integer is of the form 2^254 plus eight times a value
    // between 0 and 2^251 - 1 (inclusive).  Likewise, for X448, set the two
    // least significant bits of the first byte to 0, and the most
    // significant bit of the last byte to 1.  This means that the resulting
    // integer is of the form 2^447 plus four times a value between 0 and
    // 2^445 - 1 (inclusive).

    // <CODE BEGINS>
    // def decodeScalar25519(k):
    //     k_list = [ord(b) for b in k]
    //     k_list[0] &= 248
    //     k_list[31] &= 127
    //     k_list[31] |= 64
    //     return decodeLittleEndian(k_list, 255)

    bytes[0] &= 248; //1111 1000
    bytes[31] &= 127; //0111 1111
    bytes[31] |= 64; //0100 0000


    const byteBuffer = Buffer.from(bytes);
    console.log("Generated byte buffer");
    console.log(byteBuffer);

    const generatedKey = SignalLib.PrivateKey.deserialize(byteBuffer);
    console.log(generatedKey.serialize());

    // Compare buffers byte by byte
    const serializedSignalKey = generatedKey.serialize();
    let areSame = true;
    for(let i=0;i<length;i++) {
        if(serializedSignalKey[i]!=byteBuffer[i]){
            areSame=false;
            console.log(`Buffers differ on index ${i}`);
        }
    }
    tape.true(areSame);
    
});


test('Deterministic prng', async (tape)=> {
    const seedLength = 32; // Same as key length should be enough
    const seed = crypto.randomBytes(seedLength);
    const range = 256;
    const deterministicRng = require('random-seed').create(seed); // Deterministic!

    deterministicRng.seed(seed); // Deterministic!
    const n1 = deterministicRng(range);
    const n2 = deterministicRng(range);

    deterministicRng.seed(seed); // Deterministic!
    const n3 = deterministicRng(range);
    const n4 = deterministicRng(range);

    tape.equal(n1, n3);
    tape.equal(n2, n4);
    console.log(`Should be same: ${n1}, ${n3} and ${n2}, ${n4}`);
});

test('Deterministic id prng', async (tape)=> {
    const seedLength = Constants.KEY_ID_SEED_LENGTH;
    const seed = crypto.randomBytes(seedLength);
    const deterministicRng = require('random-seed').create(seed); // Deterministic!

    deterministicRng.seed(seed); // Deterministic!
    const n1 = deterministicRng.intBetween(Constants.KEY_START_ID, Constants.KEY_STOP_ID);
    const n2 = deterministicRng.intBetween(Constants.KEY_START_ID, Constants.KEY_STOP_ID);
    const n3 = deterministicRng.intBetween(Constants.KEY_START_ID, Constants.KEY_STOP_ID);
    const n4 = deterministicRng.intBetween(Constants.KEY_START_ID, Constants.KEY_STOP_ID);

    deterministicRng.seed(seed); // Deterministic!
    const x1 = deterministicRng.intBetween(Constants.KEY_START_ID, Constants.KEY_STOP_ID);
    const x2 = deterministicRng.intBetween(Constants.KEY_START_ID, Constants.KEY_STOP_ID);
    const x3 = deterministicRng.intBetween(Constants.KEY_START_ID, Constants.KEY_STOP_ID);
    const x4 = deterministicRng.intBetween(Constants.KEY_START_ID, Constants.KEY_STOP_ID);

    tape.equal(n1, x1);
    tape.equal(n2, x2);
    tape.equal(n3, x3);
    tape.equal(n4, x4);
});




test('Out of ephemerals', async (tape)=> {
    const alice = await newDenimClient("Alice", 1);
    const bob = await newDenimClient("Bob", 1);

    const receiverSignedPrePKeyId = bob._signedPreKeyCounter-1;
    const receiverSignedPrePKey = await bob.signedPreKeyStore.getSignedPreKey(receiverSignedPrePKeyId);
    const receiverIdKey = await bob.identityKeyStore.getIdentity(bob.address);
    const receiverRegId = await bob.identityKeyStore.getLocalRegistrationId();

    // Simulte out of ephemerals; use null instead
    const receiverBundle = SignalLib.PreKeyBundle.new(
        receiverRegId,
        bob.address.deviceId(),
        null,
        null,
        receiverSignedPrePKeyId,
        receiverSignedPrePKey.publicKey(),
        receiverSignedPrePKey.signature(),
        receiverIdKey
    );

    tape.false(receiverBundle.preKeyPublic());

    await alice.startNewOutgoingSessionThreadUnsafe(receiverBundle, bob.address);

    //send message
    const aliceMessage = Buffer.from("Greetings from Alice", "utf8");
    const aliceCiphertext = await alice.encryptRegularThreadUnsafe(aliceMessage, bob.address);
    const bobReceivedCiphertext = SignalLib.PreKeySignalMessage.deserialize(aliceCiphertext.serialize());
    const bobDecrypted = await bob.decryptRegularPreKeyThreadUnsafe(bobReceivedCiphertext, alice.address);
    tape.equal(bobDecrypted.toString(), aliceMessage.toString());

});


test('Out of deniable ephemerals', async (tape)=> {
    const alice = await newDenimClient("Alice", 1, 10, 0);
    const bob = await newDenimClient("Bob", 1, 10, 0);
    const charlie = await newDenimClient("Charlie", 1);
    const dorothy = await newDenimClient("Dorothy", 1);

    const aliceAddressString = Util.signalAddressToString(alice.address);
    const bobAddressString = Util.signalAddressToString(bob.address);
    const charlieAddressString = Util.signalAddressToString(charlie.address);
    const dorothyAddressString = Util.signalAddressToString(dorothy.address);

    const q = 2;
    const server = new DenimServer(q);

    const aliceRegister = await alice.createRegisterThreadUnsafe();
    server.process(aliceAddressString, aliceRegister);
    const bobRegister = await bob.createRegisterThreadUnsafe();
    server.process(bobAddressString, bobRegister);
    const charlieRegister = await charlie.createRegisterThreadUnsafe();
    server.process(charlieAddressString, charlieRegister);
    const dorothyRegister = await dorothy.createRegisterThreadUnsafe();
    server.process(dorothyAddressString, dorothyRegister);

    // Alice wants to communicate deniably with Bob
    await alice.queueDeniableKeyRequest(bob.address);
    await alice.queueDeniableMessage("Privet "+bob.address.name()+"...", bob.address);
    tape.equal(alice.deniableMessagesAwaitingEncryption.get(bobAddressString).length, 1);

    const aliceCharlieKeyRequest = alice.createKeyRequest(charlie.address);
    const aliceCharlieKeyResponse = server.process(aliceAddressString, aliceCharlieKeyRequest)["msg"];
    let decoded = denim_proto.DenimMessage.decode(aliceCharlieKeyResponse);
    await alice.process(decoded);

    // Server processes *after* responding
    const denimMsg1 = denim_proto.DenimMessage.decode(Buffer.from(aliceCharlieKeyRequest));
    await server._processChunks(aliceAddressString, denimMsg1.chunks);


    const aliceCharlieMsg1 = await alice.createRegularMessage("Very long message for Charlie to flush out the deniable key request", charlie.address);
    const aliceCharlieMsg1Forward = server.process(aliceAddressString, aliceCharlieMsg1)["msg"];
    decoded = denim_proto.DenimMessage.decode(aliceCharlieMsg1Forward);
    await charlie.process(decoded);

    // Server processes *after* responding
    const denimMsg2 = denim_proto.DenimMessage.decode(Buffer.from(aliceCharlieMsg1));
    await server._processChunks(aliceAddressString, denimMsg2.chunks);

    // Charlie should respond so Alice can get the deniable key response
    const aliceCharlieMsg2 = await charlie.createRegularMessage("Hello Alice! Let me send you something very long so you can get the key response with this message", alice.address);
    const aliceCharlieMsg2Forward = server.process(charlieAddressString, aliceCharlieMsg2)["msg"];
    decoded = denim_proto.DenimMessage.decode(aliceCharlieMsg2Forward);
    await alice.process(decoded); // Should contain key response
    
    // Server processes *after* responding
    const denimMsg3 = denim_proto.DenimMessage.decode(Buffer.from(aliceCharlieMsg2));
    await server._processChunks(charlieAddressString, denimMsg3.chunks);

    const aliceCharlieMsg3 = await alice.createRegularMessage("Very long message 2 for Charlie to flush out the deniable message", charlie.address);
    const aliceCharlieMsg3Forward = server.process(aliceAddressString, aliceCharlieMsg3)["msg"];
    decoded = denim_proto.DenimMessage.decode(aliceCharlieMsg3Forward);
    await charlie.process(decoded);

    // Server processes *after* responding
    const denimMsg4 = denim_proto.DenimMessage.decode(Buffer.from(aliceCharlieMsg3));
    await server._processChunks(aliceAddressString, denimMsg4.chunks);

    // Push Bob's message out using Dorothy
    // Key Request
    const dorothyBobKeyRequest = dorothy.createKeyRequest(bob.address);
    const dorothyBobKeyResponse = server.process(dorothyAddressString, dorothyBobKeyRequest)["msg"];
    decoded = denim_proto.DenimMessage.decode(dorothyBobKeyResponse);
    await dorothy.process(decoded);

     // Server processes *after* responding
     const denimMsg5 = denim_proto.DenimMessage.decode(Buffer.from(dorothyBobKeyRequest));
     await server._processChunks(dorothyAddressString, denimMsg5.chunks);

    //Regular message Dorothy->Bob
    const dorothyBobMsg1 = await dorothy.createRegularMessage("Very long message for Bob to flush out Alice's deniable message", bob.address);
    const dorothyBobMsg1Forward = server.process(dorothyAddressString, dorothyBobMsg1)["msg"];
    decoded = denim_proto.DenimMessage.decode(dorothyBobMsg1Forward);
    await bob.process(decoded);
    tape.true(decoded.counter==bob.generatorCounter); //Counters should match

    
    const bobServerGeneratedIds = server.generatedIds.get(bobAddressString);
    const bobClientGeneratedIds = bob.deniableKeyIds;

    console.log(bobServerGeneratedIds);
    console.log(bobClientGeneratedIds);

});